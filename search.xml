<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[”js实现轮播图“]]></title>
    <url>%2F2019%2F08%2F31%2F%E2%80%9Djs%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%E2%80%9C%2F</url>
    <content type="text"><![CDATA[本文部分参考手把手原生js简单轮播图轮播图的原理： 一系列的大小相等的图片平铺，利用CSS布局只显示一张图片，其余隐藏。通过计算偏移量利用定时器实现自动播放，或通过手动点击事件切换图片。 See the Pen 轮播图 by Myongchon_Lau (@myongchon)on CodePen. 相关阅读 Vue轮播图的实现以及其与jQuery轮播图的简单对比]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue仿百度搜索功能]]></title>
    <url>%2F2019%2F08%2F23%2Fvue%E4%BB%BF%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[所用知识1. 样式：bootstrap2. 常见：vue-resource.js(ajax库)，实现跨域请求 html代码 123456789&lt;div class=&quot;container search-container&quot; id=&quot;app&quot;&gt;&lt;h1 class=&quot;title&quot; &gt;baidu-search&lt;/h1&gt;&lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入想要搜索关键字&quot; v-model=&quot;keyword&quot; @keyup=&quot;get($event)&quot; @keydown.down.prevent=&quot;selectDown&quot;@keydown.up.prevent=&quot;selectUp&quot;&gt;&lt;ul&gt;&lt;li class=&quot;text-center&quot; v-for=&quot;(value,index) in myData&quot;&gt;&lt;span class=&quot;text-success textprimary&quot; :class=&quot;&#123;gray:index==now&#125;&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p &gt;&lt;h2 v-show=&quot;myData.length==0&quot; class=&quot;text-warning text-center&quot;&gt;暂时无数据&lt;/h2&gt;&lt;/p&gt;&lt;/div&gt; js代码 123456789101112131415161718192021222324252627282930313233343536new Vue(&#123;el:&apos;#app&apos;,data:&#123;myData:[],keyword:&apos;&apos;,now:-1&#125;,methods:&#123;get:function (event) &#123;if(event.keyCode==38||event.keyCode==40)return;if(event.keyCode==13)&#123;window.open(&apos;https://www.baidu.com/s?wd=&apos;+this.keyword);this.keyword=&apos;&apos;&#125;this.$http.jsonp(&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&apos;,&#123;wd:this.keyword&#125;,&#123;jsonp:&apos;cb&apos;&#125;).then(function (res) &#123;this.myData=res.data.s;&#125;,function () &#123;&#125;);&#125;,selectDown:function () &#123;this.now++;if(this.now==this.myData.length)this.now=-1;this.keyword=this.myData[this.now];&#125;,selectUp:function () &#123;this.now--;if(this.now==-2)this.now=this.myData.length-1;this.keyword=this.myData[this.now];&#125;&#125;&#125;) get方法实现获取下拉数据和搜索功能，输入keyword之后，调用get方法使用jsonp获取提示数据，然后赋值给myData，然后使用v-for遍历提示数据 然后selectDown和selectUp实现上下选中数据，当按下回车键时，实现搜索 实现效果See the Pen]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行机制]]></title>
    <url>%2F2019%2F08%2F13%2FJavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、场景分析See the Pen abodVQw by Myongchon_Lau (@myongchon)on CodePen. 执行结果：1234//&quot;执行Promise&quot;//&quot;代码执行结束&quot;//&quot;执行then函数啦&quot;//&quot;定时器开始&quot; 2、执行机制相关知识点2.1、关于javascript javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的。 2.2、javascript的同步和异步 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 1、同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。2、当Event Table中指定的事情完成时，会将这个函数移入Event Queue。3、主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。4、上述过程会不断重复，也就是常说的Event Loop(事件循环)。5、我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 2.3、JavaScript的宏任务与微任务 你是否觉得同步异步的执行机制流程就是JavaScript执行机制的全部？不是的，JavaScript除了广义上的的同步任务何异步任务，其对任务还有更精细的定义：macro-task(宏任务)：包括整体代码script，setTimeout，setIntervalmicro-task(微任务)：Promise，process.nextTick不同类型的任务会进入对应的Event Queue。事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量提升]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[在ECMAScript5中，JS只有两类作用域：全局作用域、函数作用域。 全局作用域：全局对象的作用域，在代码的任何地方都可访问，但有时会被函数作用域覆盖 函数作用域：作用于整个函数范围内，不管到底是在函数中的何处进行声明 1234567891011121314151617181920// 全局变量var i = 100;// 函数声明，outer是一个外部函数function outer()&#123;// 访问全局变量console.log(i); // 100// 函数声明，inner是一个内部函数function inner()&#123;// 内部函数的内部进行了变量提升，也就是第二部分叙述的内容console.log(i); // undefined// 这里的i是局部变量，作用域仅在函数内var i = 1;// 局部变量覆盖全局变量，或者说是函数作用域覆盖全局作用域console.log(i); // 1&#125;inner();// 这里的i是全局变量console.log(i); // 100&#125;outer(); 定义变量时，如果不写var，那么就会相当于声明了一个全局变量，作用域为全局作用域；否则声明的是局部变量，作用域为函数作用域。在以上代码段中，第一行的var i = 0是全局变量，虽然它添加var，但是在全局范畴中声明，而且不在函数范围内，因此效果等同于i = 0。但是在JS编程中应该尽力避免不加var，即使真的需要全局变量，也应该在最外层作用域中使用var声明。 ##变量提升的概念 变量提升的概念：当栈内存（作用域）形成，JS 代码自上而下执行之前，浏览器首先会把所有带 var / function 关键字开头的进行提前声明或者定义，这种预先处理机制称为“变量提升”。 声明（declare）：var a （默认 undefined）定义（defined）：a = 12（定义其实就是赋值操作） 变量提升阶段： 带 var 是只提升声明未定义（给个默认值 undefined） 带 function 是提升声明和定义都完成了 1234567console.log(a); //=&gt; undefined，如果后面都没有声明，那么就会报错var a = 12;b(); //=&gt; 1，可以直接使用，如果后面没有定义，那么会报错function b() &#123;console.log(1);&#125; 因为用 function 关键字声明的函数 ，在变量提升阶段已经赋好值了，所以我们可以在 JS 文件中的任意位置调用这个函数 变量的声明会被自动移到函数或者全局代码的最顶上。移动的仅仅是declarations，变量的定义并不会随之提升，如下代码：12345678var date = new Date();function fn()&#123;console.log(date);if(true)&#123;var date = &apos;hello&apos;;&#125;&#125;fn(); 结果并不是date的toString方法返回的结果，而是undefined，因为以上代码等价于：123456789101112// 变量声明提升var date;date = new Date();function fn()&#123;// 变量声明提升，但是此时未定义变量的值var date;console.log(date);if(true)&#123;date = &quot;hello&quot;;&#125;&#125;fn(); 但是在变量提升中还存在着一些特殊情况，因为在ES5中，变量声明、函数声明都会被提升，这就衍生出很多值得辨析的问题。 在ES6中，`function , let, class, const`也会被提升，但是提升机制又与变量提升、函数提升有所区别* ###四大原则 所有声明都会被提升到对应作用域的顶上 同一个变量声明只进行一次，其他重复声明会被JS解析忽略 函数声明进行提升时会连带函数定义一起提升 遵循前三项原则多多动手写等价转换，就一定不会出错]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Hexo文章中嵌入CodePen]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E5%B5%8C%E5%85%A5CodePen%2F</url>
    <content type="text"><![CDATA[在文章中嵌入 CodePen Hexo 官方插件页搜索codepen，然后找到hexo-codepen 或直接点击此处 1.安装npm 安装：$ npm install hexo-codepen --save或 yarn 安装：$ yarn add hexo-codepen 2.用法语法结构： 1&#123;% codepen userId|anonymous|anon slugHash theme [defaultTab [height [width]]] %&#125; demo： https://codepen.io/CiTA/pen/bgjKKE 在 CodePen 里面 Embed 出来的html代码： 12&lt;p data-height=&quot;265&quot; data-theme-id=&quot;dark&quot; data-slug-hash=&quot;bgjKKE&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;CiTA&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;CSS sidebar toggle&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/CiTA/pen/bgjKKE/&quot;&gt;CSS sidebar toggle&lt;/a&gt; by Silvestar Bistrović (&lt;a href=&quot;https://codepen.io/CiTA&quot;&gt;@CiTA&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;&lt;script async src=&quot;https://production-assets.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt; 参数对应关系： 字段 值 userId CiTA slugHash bgjKKE theme dark defaultTab css,result height 265 width 默认为：100%，此值根据博客主题进行调整 示例效果： 12#替换参数后的语法：(*设置宽高时不要用%，会导致编译错误*)&#123;% codepen CiTA bgjKKE dark [css,result [265]] %&#125; 运行后： 直接嵌入源码（CodePen 中 Embed 出来的代码支持3种格式：WordPress Shortcode、iFrame、HTML）效果如下： See the Pen CSS sidebar toggle by Silvestar Bistrović (@CiTA) on CodePen.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2019%2F07%2F14%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间 实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟123456789101112131415161718//防抖debounce代码：function debounce(fn) &#123;let timeout = null; // 创建一个标记用来存放定时器的返回值return function () &#123;// 每当用户输入的时候把前一个 setTimeout clear 掉clearTimeout(timeout); // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数timeout = setTimeout(() =&gt; &#123;fn.apply(this, arguments);&#125;, 500);&#125;;&#125;// 处理函数function handle() &#123;console.log(Math.random());&#125;// 滚动事件window.addEventListener(&apos;scroll&apos;, debounce(handle)); 节流 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return12345678910111213141516171819202122//节流throttle代码：function throttle(fn) &#123;let canRun = true; // 通过闭包保存一个标记return function () &#123;// 在函数开头判断标记是否为true，不为true则returnif (!canRun) return;// 立即设置为falsecanRun = false;// 将外部传入的函数的执行放在setTimeout中setTimeout(() =&gt; &#123; // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。// 当定时器没有执行的时候标记永远是false，在开头被return掉fn.apply(this, arguments);canRun = true;&#125;, 500);&#125;;&#125;function sayHi(e) &#123;console.log(e.target.innerWidth, e.target.innerHeight);&#125;window.addEventListener(&apos;resize&apos;, throttle(sayHi)); 总结： 函数防抖：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域请求]]></title>
    <url>%2F2019%2F07%2F14%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一、什么是跨域？1.什么是同源策略及其限制内容？同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 url的组成 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容DOM 节点AJAX 请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源： 2.常见跨域场景当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示： image 特别说明两点：第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-leaflet实践(1)]]></title>
    <url>%2F2019%2F07%2F14%2Fvue-leaflet%E5%AE%9E%E8%B7%B5(1)%2F</url>
    <content type="text"><![CDATA[单文件组件结构 命名：xx.vue位置：位于pages文件夹下一般来说，我们需要在单文件组件结构中定义那么几个标签 /8787263-6fb2238c101d48a7.webp) ##地图显示功能1.全局安装vue1npm install -g vue-cli 2.创建项目1vue init webpack vue_leaflet 3.进入项目中12cd vue_leafletnpm start //http://localhost:8080测试 4.安装leaflet1npm install leaflet --save index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;&lt;link href=&quot;//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.3.4/dist/leaflet.css&quot;/&gt;&lt;title&gt;test_bus_station&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/leaflet@1.3.4/dist/leaflet.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 单文件（.vue）123456789101112131415161718192021222324252627282930&lt;template&gt;&lt;div&gt;&lt;div id=&quot;mapid&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;https://unpkg.com/leaflet@1.3.4/dist/leaflet.js&quot;&gt;&lt;/script&gt;&lt;script&gt;export default &#123;name: &apos;BusStation&apos;,data () &#123;return &#123;map: null&#125;&#125;,mounted () &#123;this.map = L.map(&apos;mapid&apos;).setView([36.49771311230842, 109.45744048529967], 13)// 加载谷歌地图L.tileLayer(&apos;http://mt0.google.cn/vt/lyrs=m@160000000&amp;hl=zh-CN&amp;gl=CN&amp;src=app&amp;y=&#123;y&#125;&amp;x=&#123;x&#125;&amp;z=&#123;z&#125;&amp;s=Ga&apos;, &#123;attribution: &apos;© &lt;a href=&quot;http://osm.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt; contributors&apos;&#125;).addTo(this.map)// 加载高德地图// L.tileLayer(&apos;http://webrd0&#123;s&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&apos;, &#123;// subdomains:&quot;1234&quot;// &#125;).addTo(this.map)&lt;br&gt;&lt;br&gt; // 在地图上添加标记&lt;br&gt; L.marker([data.lat, data.lng]).addTo(this.map)&lt;br&gt; // 在地图上画圆圈&lt;br&gt; L.circle([data.lat, data.lng], &#123;&lt;br&gt; color: &apos;red&apos;,&lt;br&gt; fillColor: &apos;#f03&apos;,&lt;br&gt; fillOpacity: 0.5,&lt;br&gt; radius: 3&lt;br&gt; &#125;).addTo(this.map)&lt;br&gt; &#125;&#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#mapid &#123; height: 1080px; &#125;&lt;/style&gt; /16749538-a08a252cf1f5542e.png)]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码与解码]]></title>
    <url>%2F2019%2F07%2F14%2F%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编码函数：escape,encodeURI,encodeURIComponent解码函数：unescape,decodeURI,decodeURIComponent ##实例 1、escape()1234567&lt;script type=&quot;text/javascript&quot;&gt; document.write(escape(&quot;Visit W3School!&quot;) + &quot;&lt;br /&gt;&quot;) document.write(escape(&quot;?!=()#%&amp;&quot;))&lt;/script&gt;输出结果：Visit%20W3School%21%3F%21%3D%28%29%23%25%26 2、encodeURI()1234567891011121314&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.write(encodeURI(&quot;http://www.w3school.com.cn&quot;)+ &quot;&lt;br /&gt;&quot;)document.write(encodeURI(&quot;http://www.w3school.com.cn/My first/&quot;)+ &quot;&lt;br /&gt;&quot;)document.write(encodeURI(&quot;,/?:@&amp;=+$#&quot;))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;输出结果：http://www.w3school.com.cnhttp://www.w3school.com.cn/My%20first/,/?:@&amp;=+$#对整个URL进行编码，而URL的特定标识符不会被转码。 3、encodeURIComponent()123456789101112&lt;script type=&quot;text/javascript&quot;&gt;document.write(encodeURIComponent(&quot;http://www.w3school.com.cn&quot;))document.write(&quot;&lt;br /&gt;&quot;)document.write(encodeURIComponent(&quot;http://www.w3school.com.cn/p 1/&quot;))document.write(&quot;&lt;br /&gt;&quot;)document.write(encodeURIComponent(&quot;,/?:@&amp;=+$#&quot;))&lt;/script&gt;输出结果：http%3A%2F%2Fwww.w3school.com.cnhttp%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2F%2C%2F%3F%3A%40%26%3D%2B%24%23对URL中的参数进行编码，因为参数也是一个URL，如果不编码会影响整个URL的跳转。 4、unescape()12345678910&lt;script type=&quot;text/javascript&quot;&gt;var test1=&quot;Visit W3School!&quot;test1=escape(test1)document.write (test1 + &quot;&lt;br /&gt;&quot;)test1=unescape(test1)document.write(test1 + &quot;&lt;br /&gt;&quot;)&lt;/script&gt;输出：Visit%20W3School%21Visit W3School! ###5、decodeURI()12345678&lt;script type=&quot;text/javascript&quot;&gt;var test1=&quot;http://www.w3school.com.cn/My first/&quot;document.write(encodeURI(test1)+ &quot;&lt;br /&gt;&quot;)document.write(decodeURI(test1))&lt;/script&gt;输出：http://www.w3school.com.cn/My%20first/http://www.w3school.com.cn/My first/ ###5、decodeURIComponent()12345678&lt;script type=&quot;text/javascript&quot;&gt;var test1=&quot;http://www.w3school.com.cn/My first/&quot;document.write(encodeURIComponent(test1)+ &quot;&lt;br /&gt;&quot;)document.write(decodeURIComponent(test1))&lt;/script&gt;输出：http%3A%2F%2Fwww.w3school.com.cn%2FMy%20first%2Fhttp://www.w3school.com.cn/My first/ 参考：js 中编码（encode）和解码（decode）的三种方法 escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。而encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。 1、传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。例如：document.write(‘&lt;a href=”http://passport.baidu.com/?logout&amp;aid=7&amp;u=’+encodeURIComponent(“http://cang.baidu.com/bruce42“)+’”&gt;退出‘); 2、进行url跳转时可以整体使用encodeURI例如：Location.href=encodeURI(“http://cang.baidu.com/do/s?word=百度&amp;ct=21”); 3、 js使用数据时可以使用escape例如：搜藏中history纪录。 4、escape对0-255以外的unicode值进行编码时输出%u**格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。最多使用的应为encodeURIComponent，它是将中文、韩文等特殊字符转换成utf-8格式的url编码，所以如果给后台传递参数需要使用encodeURIComponent时需要后台解码对utf-8支持（form中的编码方式和当前页面编码方式相同）escape不编码字符有69个：，+，-，.，/，@，_，0-9，a-z，A-ZencodeURI不编码字符有82个：!，#，$，&amp;，’，(，)，，+，,，-，.，/，:，;，=，?，@，，~，0-9，a-z，A-ZencodeURIComponent不编码字符有71个：!， ‘，(，)，，-，.，*，~，0-9，a-z，A-Z]]></content>
  </entry>
  <entry>
    <title><![CDATA[根据不同的环境打包（npm run build -- xx)]]></title>
    <url>%2F2019%2F07%2F14%2Fwebpack%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1&gt; build.js 文件添加1process.env.NODE_ENV = process.argv.splice(2)[0] == &apos;dev&apos;? &apos;develop&apos;:&apos;production&apos; 2&gt; prod.env.js &amp; dev.env.jd 文件添加在生产或开发环境需要添加的变量12DROP_DEBUGGER: true,DROP_CONSOLE: true 3&gt; webpack.prod.conf.js 中添加判断 &amp; 配置参数(1) let env = require(&apos;../config/prod.env&apos;) if (process.env.NODE_ENV == &apos;develop&apos;) { env = require(&apos;../config/dev.env&apos;) } console.log(&quot;----&quot;); console.log(env.DROP_CONSOLE); //让打包的时候输出可配置的文件 var GenerateAssetPlugin = require(&apos;generate-asset-webpack-plugin&apos;); var createServerConfig=function(compilation){ // console.log(&quot;info from GenerateAssetPlugin:&quot;); // console.log(compilation); let cfgJson={ApiUrl:&quot;http://10.0.0.200:18080&quot;}; return JSON.stringify(cfgJson); } new UglifyJsPlugin({ uglifyOptions: { compress: { warnings: false, drop_debugger: env.DROP_DEBUGGER, drop_console: env.DROP_CONSOLE } }, sourceMap: config.build.productionSourceMap, parallel: true }),]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[####Cookie1.来源Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies），一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies）。Cookie时效性：目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。Cookie使用限制：Cookie 必须在 HTML 文件的内容输出之前设置；不同的浏览器 (Netscape Navigator、Internet Explorer) 对 Cookie 的处理不一致，使用时一定要考虑；客户端用户如果设置禁止 Cookie，则 Cookie 不能建立。 并且在客户端，一个浏览器能创建的 Cookie 数量最多为 300 个，并且每个不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个。1客户端会发送一个http请求到服务器端。2服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。3在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。 ##2.SessionSession是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时Cookie），如果没有则会添加Session，如果有就拿出这个Session来做相关操作。由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了。Session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。 ##3.Tokentoken是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。 Cookie和Session的区别:1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[href与src的区别]]></title>
    <url>%2F2019%2F07%2F14%2Fhref%E4%B8%8Esrc%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[###两者的定义href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。当我们写下：1&lt; link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; / &gt; 浏览器明白当前资源是一个样式表，页面解析不会暂停（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。这与把css文件内容写在标签里不相同，因此建议使用link标签而不是@import来吧样式表导入到html文档里。src (Source)属性仅仅 嵌入当前资源到当前文档元素定义的位置。当浏览器找到1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 在浏览器下载，编译，执行这个文件之前页面的加载和处理会被暂停。这个过程与把js文件放到标签里类似。这也是建议把JS文件放到底部加载的原因。当然，img标签页与此类似。浏览器暂停加载直到提取和加载图像。 ###两者区别href和src是有区别的，而且是不能相互替换的。(1)我们在可替换的元素*上使用src，然而把href用于在涉及的文档和外部资源之间建立一个链接或者关系。(2)在浏览器下载，编译，执行src的值时，之前页面的加载和处理会被暂停；浏览器遇到href的值，页面解析不会暂停。 注，可替换元素： CSS 里，可替换元素（replaced element）的展现不是由CSS来控制的。这些元素是一类外观渲染独立于CSS的 外部对象。 典型的可替换元素有 &lt; img&gt;、 、 和 表单元素，如、 。 某些元素只在一些特殊情况下表现为可替换元素，例如 和 。 通过 CSS content 属性来插入的对象 被称作 匿名可替换元素（anonymous replaced elements）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[浏览器兼容浏览器内核主要分为两种，一是渲染引擎，另一个是js引擎，内核更加倾向于说渲染引擎。市场上常见的浏览器内核主要有四种：Webkit内核、Presto内核、Trident内核、Gecko内核。 ###常见的浏览器兼容性可分为三类：1. HTML兼容 不同浏览器的标签默认的margin和padding不同解决方案：css里增加通配符*{margin：0；padding：0} IE6双边距问题；在IE6中设置了float，同时又设置margin，就会出现边距问题解决方案：设置display：inline； 当标签的高度设置小于10px，在IE6、IE7中会超出设置的高度解决方案：超出高度的标签设置overflow：hidden，或者设置line-height的值小于设置高度 图片默认有间距解决方案：使用float为img布局 IE9以下浏览器不能使用opacity解决方案：opacity：0.5；filter：alfha（opacity=50）；filter：progid：DXlmageTransform.Microsoft.Alfha(style=0,opacity=50); 边距重叠问题；当相邻两个元素都设置了margin边距时，margin将取最大值，舍弃最小值； cursor：hand显示手型在safari上不支持解决方案：统一使用cursor：pointer 两个块级元素，父元素设置了overflow：auto；子元素设置了position：relative；且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；解决方案：父级元素设置position：relative const问题说明：Firefox下，可以使用const关键字来定义常量；IE下，只能使用var关键字来定义常量。解决方法：统一使用var关键字来定义常量。 event.srcElement问题问题说明：IE下，event对象有srcElement属性，但是没有target属性；Firefox下，event对象有target属性，但是没有srcElement属性。解决方法：使用srcObj = event.srcElement?event.srcElement:event.target; 事件绑定IE:dom.attachEvent();其他浏览器：dom.addEventListener();标准浏览器采用事件捕获的方式对应IE的事件冒泡机制（即标准由最外元素至最内元素或者IE由最内元素到最外元素）最后标准方亦觉得IE这方面的比较合理，所以便将事件冒泡纳入了标准，这也是addEventListener第三个参数的由来，而且事件冒泡作为了默认值。 操作tr的html在ie9以下，不能操作tr的innerHTML ajax略有不同IE：ActiveXObject其他：xmlHttpRequest 对象宽高赋值问题问题说明：FireFox中类似obj.style.height = imgObj.height的语句无效。 2. CSS兼容 cursor:hand VS cursor:pointer firefox不支持hand，但ie支持pointer解决方法: 统一使用pointer innerText在IE中能正常工作，但在FireFox中却不行. 需用textContent。解决方法:12345if(navigator.appName.indexOf(&quot;Explorer&quot;) &gt; -1)&#123;document.getElementById(&apos;element&apos;).innerText = &quot;my text&quot;;&#125; else&#123;document.getElementById(&apos;element&apos;).textContent = &quot;my text&quot;;&#125; CSS透明 IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。FF：opacity:0.6。 css中的width和padding 在IE7和FF中width宽度不包括padding，在Ie6中包括padding. FF和IEBOX模型解释不一致导致相差2px box.style{width:100;border1px;}ie理解为box.width =100ff理解为box.width =100 + 1*2 = 102 //加上边框2px 解决方法：div{margin:30px!important;margin:28px;}注意这两个margin的顺序一定不能写反， IE不能识别!important这个属性，但别的浏览器可以识别。所以在IE下其实解释成这样：div{maring:30px;margin:28px}重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important; IE5 和IE6的BOX解释不一致 IE5下div{width:300px;margin:0 10px 0 10px;}div 的宽度会被解释为300px-10px(右填充)-10px(左填充)，最终div的宽度为280px，而在IE6和其他浏览器上宽度则是以 300px+10px(右填充)+10px(左填充)=320px来计算的。这时我们可以做如下修改div{width:300px!important;width /**/:340px;margin:0 10px 0 10px} ul和ol列表缩进问题 消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。 元素水平居中问题 FF: margin:0auto; IE: 父级{ text-align:center; } Div的垂直居中问题 vertical-align:middle; 将行距增加到和整个DIV一样高：line-height:200px;然后插入文字，就垂直居中了。缺点是要控制内容不要换行。 margin加倍的问题 设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上display:inline; 例如：123456&lt;divid=”imfloat”&gt;相应的css为# imfloat&#123;float:left;margin:5px;//IE下理解为10pxdisplay:inline;//IE下再理解为5px&#125; IE与宽度和高度的问题 IE不认得min-这个定义，但实际上它把正常的width和height当作有min的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。 比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样： 1#box&#123; width: 80px; height: 35px;&#125;html&gt;body #box&#123; width: auto;height: auto; min-width: 80px; min-height: 35px;&#125; 页面的最小宽度 如上一个问题，IE不识别min，要实现最小宽度，可用下面的方法： 1#container&#123; min-width: 600px;width:expression(document.body.clientWidth＜ 600? &quot;600px&quot;: &quot;auto&quot; );&#125; 第一个min-width是正常的；但第2行的width使用了Javascript，这只有IE才认得，这也会让你的HTML文档不太正规。它实际上通过Javascript的判断来实现最小宽度。 DIV浮动IE文本产生3象素的bug 左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距. 12345678#box&#123; float:left; width:800px;&#125; #left&#123; float:left; width:50%;&#125; #right&#123; width:50%;&#125; *html #left&#123; margin-right:-3px; //这句是关键&#125; &lt;div id=&quot;box&quot;&gt;&lt;div id=&quot;left&quot;&gt;＜/div&gt;&lt;div id=&quot;right&quot;&gt;＜/div&gt;&lt;/div&gt; IE捉迷藏的问题 当div应用复杂的时候每个栏中又有一些链接，DIV等这个时候容易发生捉迷藏的问题。 有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。 解决办法：对#layout使用line-height属性或者给#layout使用固定高和宽。页面结构尽量简单。 float的div闭合;清除浮动;自适应高度 ① 例如：＜div id=”floatA”&gt;＜div id=”floatB”&gt;＜div id=”NOTfloatC”&gt; 这里的NOTfloatC并不希望继续平移，而是希望往下排。(其中floatA、floatB的属性已经设置为float:left;) 这段代码在IE中毫无问题，问题出在FF。原因是NOTfloatC并非float标签，必须将float标签闭合。在＜divclass=”floatB”&gt;＜div class=”NOTfloatC”&gt;之间加上＜div class=”clear”&gt;这个div一定要注意位置，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系，否则会产生异常。并且将clear这种样式定义为为如下即可：.clear{clear:both;} ②作为外部 wrapper 的 div 不要定死高度,为了让高度能自适应，要在wrapper里面加上overflow:hidden; 当包含float的box的时候，高度自适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊！)用zoom:1;可以做到，这样就达到了兼容。例如某一个wrapper如下定义：1.colwrapper&#123;overflow:hidden; zoom:1; margin:5px auto;&#125; ③对于排版,我们用得最多的css描述可能就是float:left.有的时候我们需要在n栏的float div后面做一个统一的背景,譬如:1234567&lt;div id=”page”&gt;&lt;div id=”left”&gt;＜/div&gt;&lt;div id=”center”&gt;＜/div&gt;&lt;div id=”right”&gt;＜/div&gt;&lt;/div&gt; 比如我们要将page的背景设置成蓝色,以达到所有三栏的背景颜色是蓝色的目的,但是我们会发现随着left centerright的向下拉长,而page居然保存高度不变,问题来了,原因在于page不是float属性,而我们的page由于要居中,不能设置成float,所以我们应该这样解决：1234567891011&lt;div id=”page”&gt;&lt;div id=”bg” style=”float:left;width:100%”&gt;&lt;div id=”left”&gt;＜/div&gt;&lt;div id=”center”&gt;＜/div&gt;&lt;div id=”right”&gt;＜/div&gt;&lt;/div&gt;&lt;/div&gt; 再嵌入一个float left而宽度是100%的DIV解决之。 ④万能float 闭合(非常重要!) 关于 clear float 的原理可参见 [How To ClearFloats Without Structural Markup],将以下代码加入Global CSS 中,给需要闭合的div加上class=”clearfix”即可,屡试不爽。1234567/* Clear Fix */.clearfix:after &#123; content:&quot;.&quot;; display:block; height:0; clear:both;visibility:hidden; &#125;.clearfix &#123; display:inline-block; &#125;/* Hide from IE Mac */.clearfix &#123;display:block;&#125;/* End hide from IE Mac *//* end of clearfix */ 或者这样设置：.hackbox{display:table; //将对象作为块元素级的表格显示} 高度不适应 高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用margin 或padding时。 例：12345#box &#123;background-color:#eee; &#125; #box p &#123;margin-top: 20px;margin-bottom: 20px; text-align:center; &#125; &lt;div id=&quot;box&quot;&gt;&lt;p&gt;p对象中的内容＜/p&gt;&lt;/div&gt; 解决技巧：在P对象上下各加2个空的div对象CSS代码{height:0px;overflow:hidden;}或者为DIV加上border属性。 IE6下图片下有空隙产生 解决这个BUG的技巧有很多,可以是改变html的排版,或者设置img为display:block或者设置vertical-align属性为vertical-align:top/bottom/middle/text-bottom都可以解决. 对齐文本与文本输入框 加上vertical-align:middle;12345678910&lt;style type=&quot;text/css&quot;&gt;input &#123;width:200px;height:30px;border:1px solid red;vertical-align:middle;&#125;&lt;/style&gt; 经验证，在IE下任一版本都不适用，而ff、opera、safari、chrome均可行 LI中内容超过长度后以省略号显示 此技巧适用与IE、Opera、safari、chrom浏览器，FF暂不支持。123456789&lt;style type=&quot;text/css&quot;&gt;li &#123;width:200px;white-space:nowrap;text-overflow:ellipsis;-o-text-overflow:ellipsis;overflow: hidden;&#125;&lt;/style&gt; 为什么web标准中IE无法设置滚动条颜色了 解决办法是将body换成html1234567891011121314&lt;!DOCTYPEhtml PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&quot;[http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd](http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd)&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gb2312&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;html &#123;scrollbar-face-color:#f6f6f6;scrollbar-highlight-color:#fff;scrollbar-shadow-color:#eeeeee;scrollbar-3dlight-color:#eeeeee;scrollbar-arrow-color:#000;scrollbar-track-color:#fff;scrollbar-darkshadow-color:#fff;&#125;＜/style&gt; 为什么无法定义1px左右高度的容器 IE6下这个问题是因为默认的行高造成的,解决的技巧也有很多：123overflow:hidden zoom:0.08 line-height:1px 链接(a标签)的边框与背景 a链接加边框和背景色，需设置 display: block, 同时设置 float: left 保证不换行。参照menubar, 给 a 和menubar设置高度是为了避免底边显示错位, 若不设 height, 可以在menubar中插入一个空格。 超链接访问过后hover样式就不出现的问题 被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决技巧是改变CSS属性的排列顺序: L-V-H-A12345678&lt;style type=&quot;text/css&quot;&gt;a:link &#123;&#125;a:visited &#123;&#125;a:hover &#123;&#125;a:active &#123;&#125;&lt;/style&gt; FORM标签 这个标签在IE中,将会自动margin一些边距,而在FF中margin则是0,因此,如果想显示一致,所以最好在css中指定margin和 padding,针对上面两个问题,我的css中一般首先都使用这样的样式ul,form{margin:0;padding:0;}。 为什么FF下文本无法撑开容器的高度 标准浏览器中固定高度值的容器是不会象IE6里那样被撑开的,那我又想固定高度,又想能被撑开需要怎样设置呢？办法就是去掉height设置min-height:200px; 这里为了照顾不认识min-height的IE6 可以这样定义:12345&#123;height:auto!important;height:200px;min-height:200px;&#125; 怎么样才能让层显示在FLASH之上呢解决的办法是给FLASH设置透明1&lt;paramname=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客迁移]]></title>
    <url>%2F2019%2F07%2F12%2FHexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[完成Hexo本地运行后，会在本地文件里生成一个public文件夹。public文件夹内是根据.md生成的html文件，也就博客的静态文件。通常情况下，我们执行： 1$ hexo d 就是把public文件夹下的文件同步到github，然后就能通过https://username.github.io/访问博客了。所以，我们的思路其实就是把静态文件和Hexo环境，分别存在username.github.io的master和hexo分支上。 由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。 也就是上传的是在本地目录里自动生成的.deploy_git里面。 其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github 所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。 上传分支首先，先在github上新建一个hexo分支，如图： 然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。 然后在本地的任意目录下，打开git bash， 1git clone git@github.com:ZJUFangzh/ZJUFangzh.github.io.git 将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。 接下来在克隆到本地的ZJUFangzh.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。 而后 123git add .git commit –m &quot;add branch&quot;git push 这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。 这样就上传完了。 更换电脑操作一样的，跟之前的环境搭建一样， 安装git 1sudo apt-get install git 设置git全局邮箱和用户名 12git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot; 设置ssh key 12345ssh-keygen -t rsa -C &quot;youremail&quot;#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话) 安装nodejs 12sudo apt-get install nodejssudo apt-get install npm 安装hexo 1sudo npm install hexo-cli -g 但是已经不需要初始化了， 直接在任意文件夹下， 1git clone git@……………… 然后进入克隆到的文件夹： 123cd xxx.github.ionpm installnpm install hexo-deployer-git --save 生成，部署： 12hexo ghexo d 然后就可以开始写你的新博客了 1hexo new newpage Tips: 不要忘了，每次写完最好都把源文件上传一下 123git add .git commit –m &quot;xxxx&quot;git push 如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了 1git pull]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript位操作]]></title>
    <url>%2F2019%2F07%2F09%2FJavaScript%E4%BD%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JavaScript中的数字都按照IEEE-754标准以64位格式存储。在位操作中，数字被转换为有符号32位格式。每次运算符会直接操作该32位数以得到结果。虽然需要转换，但这个过程与JavaScript其他数学运算和布尔操作相比要快很多。 1、&amp; 按位与&amp;是二元运算符，它以特定的方式的方式组合操作数中对应的位，如果对应的位都为1，那么结果就是1， 如果任意一个位是0 则结果就是0。 1 &amp; 3的结果为1 那我们来看看他是怎么运行的 1的二进制表示为 0 0 0 0 0 0 1 3的二进制表示为 0 0 0 0 0 1 1 根据 &amp; 的规则 得到的结果为 0 0 0 0 0 0 0 1,十进制表示就是1 2、| 按位或 |运算符跟&amp;的区别在于如果对应的位中任一个操作数为1 那么结果就是1。 1的二进制表示为 0 0 0 0 0 0 1 3的二进制表示为 0 0 0 0 0 1 1 所以 1 | 3的结果为3 3、^ 按位异或^运算符跟|类似，但有一点不同的是 如果两个操作位都为1的话，结果产生0。 1的二进制表示为 0 0 0 0 0 0 1 3的二进制表示为 0 0 0 0 0 1 1 所以 1 ^ 3的结果为2 4、~ 按位非~运算符是对位求反，1变0,0变1，也就是求二进制的反码 1的二进制表示为 0 0 0 0 0 0 1 所以 ~1 的结果是-2 5、&gt;&gt; 右移&gt;&gt;运算符使指定值的二进制所有位都右移规定的次数，对于其移动规则只需记住符号位不变，左边补上符号位即按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1。 1的二进制表示为 0 0 0 0 0 0 1 所以 1&gt;&gt;1的结果为0 6、&lt;&lt; 左移&lt;&lt;运算符使指定值的二进制所有位都左移规定的次数，对于其移动规则只需记住丢弃最高位，0补最低位即按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。 1的二进制表示为 0 0 0 0 0 0 1 所以 1&lt;&lt;1的结果为2 7、&gt;&gt;&gt; 无符号右移 所有整数字面量都是有符号整数，用31位表示数值，用第32位表示符号，0表示正数1表示负数。数值范围从-(2^31 - 1)到(2^31 - 1)。注意位0的位置在最右侧。 0是所有位为0 -1是所有位为1 -2147483648是除了最左边为1，其他都是0 2147483647是除了最左边为0外，其他都是1的整数。 正数是以真二进制形式存储的，前 31 位中的每一位都表示 2 的幂，从第 1 位（位 0）开始，表示 2^0，第 2 位（位 1）表示 2^1。没用到的位用 0 填充，即忽略不计。12var num = 18;(num).toString(2); //10010（18 = 2^4+2^1） 负数也存储为二进制代码，不过采用的形式是二进制补码 直接来例子，求-18的补码 （1）求该数字非负版本的二进制。这里也就是18的二进制（10010）（2）求二进制反码，也就是1变成0，0变成1（1111 1111 1111 1111 1111 1111 1110 1101）（3）在反码的基础上加一，注意二进制里的运算1+1=10（1111 1111 1111 1111 1111 1111 1110 1110） 但是呢，ECMAScript并不以这种二进制补码来表示负数，而是用数字绝对值的标准二进制代码前面加上负号的形式输出。12var num = -18;(num).toString(2); //-10010,“-18的显示就是这样的” 位运算符与 &amp; 两个都为1 结果才为1 保持数位对齐，用上述规则然后进行与运算。 或 | 两个都为0时，结果才为0 保持数位对齐，用上述规则然后进行或运算。 非 ~ 0变1，1变0 其实就是对数字求负，然后减一123var num = 25;var num1 = ~num;num1; //-26 异或 ^ 两个相同为0，不同为1 满足交换律，一个数和自己异或的结果是0，任何数x与0异或的结果都是本身x，任何数x与-1异或的结果都是-x。 左移 &lt;&lt; 各二进位全部左移若干位，高位丢弃，右侧低位补012var old = 2; //10var new = old &lt;&lt; 5; //1000000 右移 &gt;&gt; 各二进位全部右移若干位，有符号数，用符号位的值填充这些空位。 ##一些小技巧（1）判断奇偶（貌似很实用啊）123456//一般都是(i % 2 !== 0)来判断奇数if(i &amp; 1) &#123;//奇数需要进行的事情&#125; else &#123;//偶数需要做的事情&#125; （2）交换两个数字 一般需要一个中间变量，123var temp = a;var a = b;var b = temp; 可以用位操作符实现交换不需要中间变量123a ^= b; //a = a ^ bb ^= a; //b = b ^ a = b ^ a ^ b = a (b = a)a ^= b; //a = a ^ b = a ^ b ^ a = b; （3）变换符号 只需要求反后加1即可123function rever (n) &#123;return ~n + 1;&#125; //11 =&gt; -11 （4）求绝对值 对于负数对其取反后加1来得到正数。先移位取得符号位i &gt;&gt; 3112var i = a &gt;&gt; 31 //如果a为正数，i为0。如果a为负数，i为-1return i == 0 ? a : (~a + 1); //正数保持不变，负数变换符号。 另一种方法可以通过异或，参考异或的规则。a与i异或后减i（即加0或者加1）12var i = a &gt;&gt; 31;return (a ^ i) - i;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http-server快速构建本地服务器]]></title>
    <url>%2F2019%2F06%2F24%2Fhttp-server%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在静态页面中需要进行局域网进行访问时，可以开启这个http-server来进行访问 在静态页面中需要进行局域网进行访问时，可以开启这个http-server来进行访问 1.该环境是基于node环境的，所以必须先安装node.js 先打开命令行模式，输入 node -v如果显示了版本号，就说明已经安装完成。如果提示没有这个命令，请安装node.js，官网链接 node.js官网进行安装。 2.如果完成上一步，在node命令行下敲下 npm install http-server -g 后回车 如果提示一下命令，说明安装成功 1234C:\Users\Administrator\AppData\Roaming\npm\hs -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\http-server\bin\http-serverC:\Users\Administrator\AppData\Roaming\npm\http-server -&gt; C:\Users\Administrator\AppData\Roaming\npm\node_modules\http-server\bin\http-server+ http-server@0.11.1updated 1 package in 2.133s 3.进入你需要局域网访问的目录，敲hs命令就会显示访问的端口,复制其中一个就可以进行访问了 123456$ hsStarting up http-server, serving ./Available on:http://10.1.43.229:8080http://127.0.0.1:8080Hit CTRL-C to stop the server]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue双向绑定]]></title>
    <url>%2F2019%2F05%2F30%2FVue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[####双向绑定特点数据的双向绑定是vue实现的一大功能。使用v-model指令，实现视图和数据的双向绑定。所谓双向绑定，指的是vue实例中的data与其渲染的DOM元素的内容保持一致，无论谁被改变，另一方会相应的更新为相同的数据。这是通过设置属性访问器实现的。v-model主要用在表单的input输入框，完成视图和数据的双向绑定。v-model只能用在、、这些表单元素上。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;&apos; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用Vue.js中的v-model来添加双向绑定：1&lt;input v-model=&quot;xxx&quot;&gt; 其实上面的代码等价于下面的：1&lt;input :value=&quot;xxx&quot; @input=&quot;xxx = $event.target.value&quot;&gt; 也就是说： 双向绑定 = 单向绑定 + UI事件监听 双向绑定与单向绑定有优缺点 单向绑定：使得数据流也是单向的，对于复杂应用来说这是实施统一的状态管理（如redux）的前提。 双向绑定：在一些需要实时反应用户输入的场合会非常方便（比如多级联动菜单）。但通常认为复杂应用中这种便利比不上引入状态管理带来的优势。因为我们不知道状态什么时候发生改变，是谁造成的改变，数据变更也不会通知我们注意，Vue 虽然通过 v-model 支持双向绑定，但是如果引入了类似redux的vuex，就无法同时使用 v-model]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.jQuery 元素选择器 id选择器: $(&quot;#test&quot;);class选择器: $(&quot;.test&quot;);节点选择器: $(&quot;p&quot;); 2.jQuery 属性选择器 $(&quot;div[id]&quot;);选择所有含有id属性的div元素$(&quot;input[name=&#39;like&#39;]&quot;);选择所有的name属性等于’like’的input元素$(&quot;input[name!=&#39;like&#39;]&quot;) ;选择所有的name属性不等于’like’的input元素$(&quot;input[name^=&#39;like&#39;]&quot;);选择所有的name属性以’like’开头的input元素 ​$(&quot;input[name*=&#39;like&#39;]&quot;);选择所有的name属性包含’like’的input元素 3.jQuery CSS 选择器$(“p”).css(“background-color”,”red”); 4.jQuery 表单选择器 $(&quot;:input&quot;) 选择所有的表单输入元素，包括input, textarea, select 和 button$(&quot;:text&quot;) 选择所有的text input元素$(&quot;:password&quot;) 选择所有的password input元素$(&quot;:radio&quot;) 选择所有的radio input元素$(&quot;:checkbox&quot;) 选择所有的checkbox input元素$(&quot;:submit&quot;) 选择所有的submit input元素$(&quot;:image&quot;) 选择所有的image input元素$(&quot;:reset&quot;) 选择所有的reset input元素$(&quot;:button&quot;) 选择所有的button input元素$(&quot;:file&quot;) 选择所有的file input元素$(&quot;:hidden&quot;) 选择所有类型为hidden的input元素或表单的隐藏域备注:$(&quot;:input&quot;)和$(&quot;input&quot;)的区别 $(&quot;input&quot;)是节点选择器,表示选择所有input节点.$(&quot;:input&quot;)是表单选择器,表示选择所有表单元素,包括textarea,select. jquery选择器空格,大于号,加号和波浪号的区别(类似CSS选择器) 空格：$(&#39;parent childchild&#39;)表示获取parent下的所有的childchild节点（所有后代）。 大于号：$(&#39;parent&gt;child&#39;)表示获取parent下的所有child的第一代后代。 加号：$(&#39;pre+nextbrother&#39;)表示获得pre节点的下一个兄弟节点，相当于next()方法 波浪号：$(&#39;pre~brother&#39;)表示获取pre节点的后面的所有兄弟节点，相当于nextAll()方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[screen网页布局的自适应]]></title>
    <url>%2F2019%2F05%2F06%2Fscreen%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[media feature – 媒体部分特性 width – 定义输出设备中的页面可见区域宽度height – 定义输出设备中的页面可见区域高度device-width – 定义输出设备的屏幕可见宽度device-height – 定义输出设备的屏幕可见高度orientation – 定义’height’是否大于或等于’width’。portrait代表是（竖屏），landscape代表否（横屏）aspect-ratio – 定义width与height的比率，可以设置min/maxdevice-aspect-ratio – 定义device-width与device-height的比率。可以设置min/max。如常见的显示器比率：4/3, 16/9, 16/10resolution – 定义设备的分辨率。可以设置min/max。如：96dpi, 300dpi, 118dpcmcolor – 定义每一组输出设备的彩色原件个数。如果不是彩色设备，则值等于0。可以设置min/maxmedia query 常用方法 排他 （exclusive） 为确保在某一个条件下只有一个样式表生效，将查询条件严格划分，如下面： 1234567891011121314151617@media (max-width: 400px) &#123; html &#123; background: red; &#125;&#125;@media (min-width: 401px) and (max-width: 800px) &#123; html &#123; background: green; &#125;&#125;@media (min-width: 801px) &#123; html &#123; background: blue; &#125;&#125; 覆盖（overriding） 可以对元素设置相同优先级，使用样式顺序，通过覆盖，避免排他 1234567891011121314151617@media (min-width: 400px) &#123; html &#123; background: red; &#125;&#125;@media (min-width: 600px) &#123; html &#123; background: green; &#125;&#125;@media (min-width: 800px) &#123; html &#123; background: blue; &#125;&#125; 无线端优先（Mobile first） 默认样式假设为移动设备宽度，然后通过min-width控制扩展样式 123456789html &#123; background: red;&#125;@media (min-width: 600px) &#123; html &#123; background: green; &#125;&#125; PC优先（desktop first） 默认以宽屏进行样式设置，通过max-width控制样式覆盖 123456789html &#123; background: red;&#125;@media (max-width: 600px) &#123; html &#123; background: green; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端网络请求]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[前端网络请求的方式主要有 Ajax ，jQuery封装的 Ajax，fetch，axios、request 等开源库等。1.原生 AjaxAjax: asynchoronous javascript and xml，这种技术能够向服务器请求数据而无须重新加载整个页面，带来更好的用户体验，关于ajax的超详细介绍请移步此处2.jQuery对 Ajax 的封装$.ajax({ dataType: &#39;json&#39;, // 设置返回值类型 contentType: &#39;application/json&#39;, // 设置参数类型 headers: {&#39;Content-Type&#39;,&#39;application/json&#39;},// 设置请求头 xhrFields: { withCredentials: true }, // 跨域携带 cookie data: JSON.stringify({a: [{b:1, a:1}]}), // 传递参数 error:function(xhr,status){ // 错误处理 console.log(xhr,status); }, success: function (data,status) { // 获取结果 console.log(data,status); } })3.fetchFetch API是一个用用于访问和操纵 HTTP 管道的强大的原生 API。这种功能以前是使用 XMLHttpRequest 实现的。Fetch 提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch 还提供了单个逻辑位置来定义其他 HTTP 相关概念，例如 CORS 和 HTTP 的扩展。fetch是作为XMLHttpRequest的替代品出现的。4.jsonpfetch本身没有提供对jsonp的支持，jsonp本身也不属于一种非常好的解决跨域的方式。不过呢，多了解一种方式也不是坏事。jsonp 本身很简单，就是利用 script 标签的 src 属性不受同源策略约束，可进行跨域请求，不过服务端需要进行对应的设置才行。]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dom操作]]></title>
    <url>%2F2019%2F04%2F29%2FDom%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[javascript 原生方法对dom节点的操作具体包括：创建、添加、删除、替换、插入、复制、移动等 123456789101112131415161718192021222324252627282930313233//查找节点document.getElementById(&quot;id&quot;);// 通过id查找，返回唯一的节点document.getElementsByClassName(&quot;class&quot;);// 通过class查找，返回值为nodeList类型document.getElementsByTagName(&quot;div&quot;);// 通过标签名查找，返回值为nodeList类型//创建节点document.createDocumentFragment();//创建内存文档碎片document.createElement();//创建元素document.createTextNode();//创建文本节点 //添加节点var ele = document.getElementById(&quot;my_div&quot;);var oldEle = document.createElement(&quot;p&quot;);var newEle=document.createElement(&quot;div&quot;);ele.appendChild(oldEle);//删除节点ele.removeChild(oldEle);//替换节点ele.replaceChild(newEle,oldEle);//插入节点ele.insertBefore(oldEle,newEle);//在newEle之前插入 oldEle节点//复制节点var cEle = oldEle.cloneNode(true);//深度复制，复制节点下面所有的子节点cEle = oldEle.cloneNode(false);//只复制当前节点，不复制子节点//移动节点var cloneEle = oldEle.cloneNode(true);//被移动的节点document.removeChild(oldEle);//删除原节点document.insertBefore(cloneEle,newEle);//插入到目标节点之前]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web Worker]]></title>
    <url>%2F2019%2F04%2F29%2FWeb-Worker%2F</url>
    <content type="text"><![CDATA[HTML5引进了 Web Worker，可让JS在后台运行，执行耗时长的任务，而不影响主页面代码的执行。1.定义：Web Worker 是HTML5标准的一部分，允许一段JavaScript程序运行在主线程之外的另外一个线程中。Web Worker 规范中定义了两类工作线程，分别是专用线程Dedicated Worker和共享线程 Shared Worker，其中，Dedicated Worker只能为一个页面所使用，而Shared Worker可以被多个页面所共享，本文以前者为例。]]></content>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[w3c盒模型与IE盒模型对比例：一个盒子的 margin 为 20px，border 为 1px，padding 为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 202+12+102+200=262px、高 202+12102+50=112px，盒子的实际大小为：宽 12+102+200=222px、高 12+102+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 202+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px。在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。1、提示：背景应用于由内容和内边距、边框组成的区域。2、提示：内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。3、提示：外边距可以是负值，而且在很多情况下都要使用负值的外边距。 ####值缩写下面的值缩写以 padding 为例。 对面相等，后者省略；四面相等，只设一个。1234567891011/* 四面值 */padding: 20px;padding: 20px 20px 20px 20px;/* 上下值 右左值 */padding: 20px 10px;padding: 20px 10px 20px 10px;/* 上值 右左值 下值 */padding: 20px 10px 30px;padding: 20px 10px 30px 10px; 参考盒子模型的理解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人主页优化]]></title>
    <url>%2F2019%2F04%2F27%2F%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[##1. 常用命令123456789101112131415//Hexo的命令极简单，安装后只需要记住四个常用的即可。执行命令需要Git当前处于blog文件夹根目录下。generate 生成静态文件。hexo g//server 启动服务器。hexo s//deploy 部署网站。部署网站前，需要预先生成静态文件。hexo d//clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo clean//卸载Hexonpm uninstall hexo-cli -g 2.更换主题,以Next主题为例12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改Hexo 站点目录下的_config.yml的主题1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 3.站点初始设置（使用sublime打开save with encoding UTF-8） Site123456title: Hexo #网站标题subtitle: #网站副标题description: #网站描述author: author #您的名字language: zh-Hans #网站使用的语言(不写会导致中文乱码，或者使用sublime text编辑自动转码)timezone: Asia/Shanghai #网站时区。Hexo 默认使用您电脑的时区。 打开Hexo 站点目录下的_config.yml修改内容如下 4.设置主题风格 打开themes/next下的_config.yml文件，搜索 scheme关键字，将你需用启用的scheme 前面注释 # 去除即可。 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白#scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观scheme: Pisces # 双栏 Scheme，小家碧玉似的清新#scheme: Gemini # 类似 Pisces]]></content>
  </entry>
</search>
