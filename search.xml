<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dom操作]]></title>
    <url>%2F2019%2F04%2F29%2Fom%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[javascript 原生方法对dom节点的操作具体包括：创建、添加、删除、替换、插入、复制、移动等 123456789101112131415161718192021222324252627282930313233//查找节点document.getElementById(&quot;id&quot;);// 通过id查找，返回唯一的节点document.getElementsByClassName(&quot;class&quot;);// 通过class查找，返回值为nodeList类型document.getElementsByTagName(&quot;div&quot;);// 通过标签名查找，返回值为nodeList类型//创建节点document.createDocumentFragment();//创建内存文档碎片document.createElement();//创建元素document.createTextNode();//创建文本节点 //添加节点var ele = document.getElementById(&quot;my_div&quot;);var oldEle = document.createElement(&quot;p&quot;);var newEle=document.createElement(&quot;div&quot;);ele.appendChild(oldEle);//删除节点ele.removeChild(oldEle);//替换节点ele.replaceChild(newEle,oldEle);//插入节点ele.insertBefore(oldEle,newEle);//在newEle之前插入 oldEle节点//复制节点var cEle = oldEle.cloneNode(true);//深度复制，复制节点下面所有的子节点cEle = oldEle.cloneNode(false);//只复制当前节点，不复制子节点//移动节点var cloneEle = oldEle.cloneNode(true);//被移动的节点document.removeChild(oldEle);//删除原节点document.insertBefore(cloneEle,newEle);//插入到目标节点之前]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web Worker]]></title>
    <url>%2F2019%2F04%2F29%2Feb-Worker%2F</url>
    <content type="text"><![CDATA[HTML5引进了 Web Worker，可让JS在后台运行，执行耗时长的任务，而不影响主页面代码的执行。1.定义：Web Worker 是HTML5标准的一部分，允许一段JavaScript程序运行在主线程之外的另外一个线程中。Web Worker 规范中定义了两类工作线程，分别是专用线程Dedicated Worker和共享线程 Shared Worker，其中，Dedicated Worker只能为一个页面所使用，而Shared Worker可以被多个页面所共享，本文以前者为例。]]></content>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[w3c盒模型与IE盒模型对比]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人主页优化]]></title>
    <url>%2F2019%2F04%2F27%2F%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[##1. 常用命令123456789101112131415//Hexo的命令极简单，安装后只需要记住四个常用的即可。执行命令需要Git当前处于blog文件夹根目录下。generate 生成静态文件。hexo g//server 启动服务器。hexo s//deploy 部署网站。部署网站前，需要预先生成静态文件。hexo d//clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo clean//卸载Hexonpm uninstall hexo-cli -g 2.更换主题,以Next主题为例12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改Hexo 站点目录下的_config.yml的主题1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 3.站点初始设置（使用sublime打开save with encoding UTF-8） Site123456title: Hexo #网站标题subtitle: #网站副标题description: #网站描述author: author #您的名字language: zh-Hans #网站使用的语言(不写会导致中文乱码，或者使用sublime text编辑自动转码)timezone: Asia/Shanghai #网站时区。Hexo 默认使用您电脑的时区。 打开Hexo 站点目录下的_config.yml修改内容如下 4.设置主题风格 打开themes/next下的_config.yml文件，搜索 scheme关键字，将你需用启用的scheme 前面注释 # 去除即可。 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白#scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观scheme: Pisces # 双栏 Scheme，小家碧玉似的清新#scheme: Gemini # 类似 Pisces]]></content>
  </entry>
  <entry>
    <title><![CDATA[编码与解码]]></title>
    <url>%2F2019%2F04%2F12%2F%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编码函数：escape,encodeURI,encodeURIComponent解码函数：unescape,decodeURI,decodeURIComponent ##实例 1、escape()1234567&lt;script type=&quot;text/javascript&quot;&gt; document.write(escape(&quot;Visit W3School!&quot;) + &quot;&lt;br /&gt;&quot;) document.write(escape(&quot;?!=()#%&amp;&quot;))&lt;/script&gt;输出结果：Visit%20W3School%21%3F%21%3D%28%29%23%25%26 2、encodeURI()1234567891011121314&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.write(encodeURI(&quot;http://www.w3school.com.cn&quot;)+ &quot;&lt;br /&gt;&quot;)document.write(encodeURI(&quot;http://www.w3school.com.cn/My first/&quot;)+ &quot;&lt;br /&gt;&quot;)document.write(encodeURI(&quot;,/?:@&amp;=+$#&quot;))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;输出结果：http://www.w3school.com.cnhttp://www.w3school.com.cn/My%20first/,/?:@&amp;=+$#对整个URL进行编码，而URL的特定标识符不会被转码。 3、encodeURIComponent()123456789101112&lt;script type=&quot;text/javascript&quot;&gt;document.write(encodeURIComponent(&quot;http://www.w3school.com.cn&quot;))document.write(&quot;&lt;br /&gt;&quot;)document.write(encodeURIComponent(&quot;http://www.w3school.com.cn/p 1/&quot;))document.write(&quot;&lt;br /&gt;&quot;)document.write(encodeURIComponent(&quot;,/?:@&amp;=+$#&quot;))&lt;/script&gt;输出结果：http%3A%2F%2Fwww.w3school.com.cnhttp%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2F%2C%2F%3F%3A%40%26%3D%2B%24%23对URL中的参数进行编码，因为参数也是一个URL，如果不编码会影响整个URL的跳转。 4、unescape()12345678910&lt;script type=&quot;text/javascript&quot;&gt;var test1=&quot;Visit W3School!&quot;test1=escape(test1)document.write (test1 + &quot;&lt;br /&gt;&quot;)test1=unescape(test1)document.write(test1 + &quot;&lt;br /&gt;&quot;)&lt;/script&gt;输出：Visit%20W3School%21Visit W3School! ###5、decodeURI()12345678&lt;script type=&quot;text/javascript&quot;&gt;var test1=&quot;http://www.w3school.com.cn/My first/&quot;document.write(encodeURI(test1)+ &quot;&lt;br /&gt;&quot;)document.write(decodeURI(test1))&lt;/script&gt;输出：http://www.w3school.com.cn/My%20first/http://www.w3school.com.cn/My first/ ###5、decodeURIComponent()12345678&lt;script type=&quot;text/javascript&quot;&gt;var test1=&quot;http://www.w3school.com.cn/My first/&quot;document.write(encodeURIComponent(test1)+ &quot;&lt;br /&gt;&quot;)document.write(decodeURIComponent(test1))&lt;/script&gt;输出：http%3A%2F%2Fwww.w3school.com.cn%2FMy%20first%2Fhttp://www.w3school.com.cn/My first/ 参考：js 中编码（encode）和解码（decode）的三种方法 escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。而encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。 1、传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。例如：document.write(‘&lt;a href=”http://passport.baidu.com/?logout&amp;aid=7&amp;u=’+encodeURIComponent(“http://cang.baidu.com/bruce42“)+’”&gt;退出‘); 2、进行url跳转时可以整体使用encodeURI例如：Location.href=encodeURI(“http://cang.baidu.com/do/s?word=百度&amp;ct=21”); 3、 js使用数据时可以使用escape例如：搜藏中history纪录。 4、escape对0-255以外的unicode值进行编码时输出%u**格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。最多使用的应为encodeURIComponent，它是将中文、韩文等特殊字符转换成utf-8格式的url编码，所以如果给后台传递参数需要使用encodeURIComponent时需要后台解码对utf-8支持（form中的编码方式和当前页面编码方式相同）escape不编码字符有69个：，+，-，.，/，@，_，0-9，a-z，A-ZencodeURI不编码字符有82个：!，#，$，&amp;，’，(，)，，+，,，-，.，/，:，;，=，?，@，，~，0-9，a-z，A-ZencodeURIComponent不编码字符有71个：!， ‘，(，)，，-，.，*，~，0-9，a-z，A-Z]]></content>
  </entry>
  <entry>
    <title><![CDATA[href与src的区别]]></title>
    <url>%2F2019%2F04%2F10%2Fhref%E4%B8%8Esrc%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[###两者的定义href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。当我们写下：1&lt; link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; / &gt; 浏览器明白当前资源是一个样式表，页面解析不会暂停（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。这与把css文件内容写在标签里不相同，因此建议使用link标签而不是@import来吧样式表导入到html文档里。src (Source)属性仅仅 嵌入当前资源到当前文档元素定义的位置。当浏览器找到1&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 在浏览器下载，编译，执行这个文件之前页面的加载和处理会被暂停。这个过程与把js文件放到标签里类似。这也是建议把JS文件放到底部加载的原因。当然，img标签页与此类似。浏览器暂停加载直到提取和加载图像。 ###两者区别href和src是有区别的，而且是不能相互替换的。(1)我们在可替换的元素*上使用src，然而把href用于在涉及的文档和外部资源之间建立一个链接或者关系。(2)在浏览器下载，编译，执行src的值时，之前页面的加载和处理会被暂停；浏览器遇到href的值，页面解析不会暂停。 注，可替换元素： CSS 里，可替换元素（replaced element）的展现不是由CSS来控制的。这些元素是一类外观渲染独立于CSS的 外部对象。 典型的可替换元素有 &lt; img&gt;、 、 和 表单元素，如、 。 某些元素只在一些特殊情况下表现为可替换元素，例如 和 。 通过 CSS content 属性来插入的对象 被称作 匿名可替换元素（anonymous replaced elements）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域请求]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一、什么是跨域？1.什么是同源策略及其限制内容？同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 url的组成 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容DOM 节点AJAX 请求发送后，结果被浏览器拦截了 但是有三个标签是允许跨域加载资源： 2.常见跨域场景当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示： image 特别说明两点：第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[用ES6定义一个react组件]]></title>
    <url>%2F2019%2F04%2F06%2F%E7%94%A8es6%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAreact%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt; &lt;p&gt;姓名: &lt;/p&gt; &lt;p&gt;年龄: &lt;/p&gt; &lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/babel&quot;&gt; /** * es6使用class的形式来创建组件,继承React的Component类, * 后面我们更多的使用这种方式来创建组件 */ class Welcome extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;h1&gt; &lt;p&gt;姓名: &#123;this.props.person.name&#125;&lt;/p&gt; &lt;p&gt;年龄: &#123;this.props.person.age&#125; &lt;/p&gt; &lt;/h1&gt; ) &#125; &#125; const person = &#123; name: &apos;huruqing&apos;, age: 108 &#125; ReactDOM.render( &lt;Welcome person=&#123;person&#125; /&gt;, document.getElementById(&apos;root&apos;) )&lt;/script&gt;]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据不同的环境打包（npm run build -- xx)]]></title>
    <url>%2F2019%2F04%2F04%2Fwebpack%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1&gt; build.js 文件添加1process.env.NODE_ENV = process.argv.splice(2)[0] == &apos;dev&apos;? &apos;develop&apos;:&apos;production&apos; 2&gt; prod.env.js &amp; dev.env.jd 文件添加在生产或开发环境需要添加的变量12DROP_DEBUGGER: true,DROP_CONSOLE: true 3&gt; webpack.prod.conf.js 中添加判断 &amp; 配置参数(1) let env = require(&apos;../config/prod.env&apos;) if (process.env.NODE_ENV == &apos;develop&apos;) { env = require(&apos;../config/dev.env&apos;) } console.log(&quot;----&quot;); console.log(env.DROP_CONSOLE); //让打包的时候输出可配置的文件 var GenerateAssetPlugin = require(&apos;generate-asset-webpack-plugin&apos;); var createServerConfig=function(compilation){ // console.log(&quot;info from GenerateAssetPlugin:&quot;); // console.log(compilation); let cfgJson={ApiUrl:&quot;http://10.0.0.200:18080&quot;}; return JSON.stringify(cfgJson); } new UglifyJsPlugin({ uglifyOptions: { compress: { warnings: false, drop_debugger: env.DROP_DEBUGGER, drop_console: env.DROP_CONSOLE } }, sourceMap: config.build.productionSourceMap, parallel: true }),]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[####Cookie1.来源Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在 RAM 中发挥作用 （此种 Cookies 称作 Session Cookies），一旦用户从该网站或服务器退出，Cookie 可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies）。Cookie时效性：目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。Cookie使用限制：Cookie 必须在 HTML 文件的内容输出之前设置；不同的浏览器 (Netscape Navigator、Internet Explorer) 对 Cookie 的处理不一致，使用时一定要考虑；客户端用户如果设置禁止 Cookie，则 Cookie 不能建立。 并且在客户端，一个浏览器能创建的 Cookie 数量最多为 300 个，并且每个不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个。1客户端会发送一个http请求到服务器端。2服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。3在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。 ##2.SessionSession是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时Cookie），如果没有则会添加Session，如果有就拿出这个Session来做相关操作。由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了。Session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。 ##3.Tokentoken是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。 Cookie和Session的区别:1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
